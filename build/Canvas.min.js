const Canvas=function(){class Viewer{children=[];constructor(contextType="2d",startEvents=true){this.dom=document.createElement("canvas");this.dom.tabIndex=0;this.dom.style.setProperty("outline","none","important");this.contextType=contextType;this.context=this.dom.getContext(contextType);if(startEvents)this.listenToEvents()}clear(){this.context.clearRect(0,0,this.width,this.height);this.children.forEach((element=>{element.propagateClear()}))}addEventListener(...args){this.dom.addEventListener(...args)}set width(value){this.dom.width=value}get width(){return this.dom.width}set height(value){this.dom.height=value}get height(){return this.dom.height}get style(){return this.dom.style}setSize(width,height,css=false){this.width=width;this.height=height;if(css){this.style.width=width;this.style.height=height}}add(...elements){elements.forEach((element=>{if(element instanceof CanvasObject){this.addChild(element);element.defineCanvas(this)}}))}addChild(element){this.children.push(element)}getChild(child){return this.children.find((value=>value==child))}isActive(){return document.activeElement===this.dom}listenToEvents(){const canvas=this.dom;canvas.addEventListener("touchstart",(evt=>{evt.preventDefault();this.details.pointer.start=Date.now();const touch=evt.touches[0];this.details.pointer.initPos.x=this.details.pointer.currentPos.x=touch.clientX*(this.width/this.dom.offsetWidth);this.details.pointer.initPos.y=this.details.pointer.currentPos.y=touch.clientY*(this.height/this.dom.offsetHeight)}));canvas.addEventListener("touchmove",(evt=>{evt.preventDefault();const touch=evt.touches[0];this.details.pointer.currentPos.x=touch.clientX*(this.width/this.dom.offsetWidth);this.details.pointer.currentPos.y=touch.clientY*(this.height/this.dom.offsetHeight)}));canvas.addEventListener("touchend",(evt=>{evt.preventDefault();this.details.pointer.end=Date.now();this.details.pointer.finalPos.x=this.details.pointer.currentPos.x;this.details.pointer.finalPos.y=this.details.pointer.currentPos.y;this.emitTouch(evt);this.details.pointer.currentPos.x=undefined;this.details.pointer.currentPos.y=undefined}));canvas.addEventListener("mousedown",(evt=>{this.details.pointer.start=Date.now();this.details.pointer.initPos.x=evt.offsetX*(this.width/this.dom.offsetWidth);this.details.pointer.initPos.y=evt.offsetY*(this.height/this.dom.offsetHeight)}));canvas.addEventListener("mousemove",(evt=>{this.details.pointer.currentPos.x=evt.offsetX*(this.width/this.dom.offsetWidth);this.details.pointer.currentPos.y=evt.offsetY*(this.height/this.dom.offsetHeight)}));canvas.addEventListener("mouseup",(evt=>{this.details.pointer.end=Date.now();this.details.pointer.finalPos.x=this.details.pointer.currentPos.x;this.details.pointer.finalPos.y=this.details.pointer.currentPos.y;this.emitClick(evt);this.details.pointer.finalPos.x=undefined;this.details.pointer.finalPos.y=undefined}));canvas.addEventListener("mouseleave",(evt=>{this.details.pointer.currentPos.x=undefined;this.details.pointer.currentPos.y=undefined}));canvas.addEventListener("keydown",(evt=>{this.details.keyboard.keys[evt.key]=true}));canvas.addEventListener("keyup",(evt=>{this.details.keyboard.keys[evt.key]=false;this.emitKeyRelease(evt.key)}));canvas.addEventListener("contextmenu",(evt=>{if(!this.forceContextDefault)evt.preventDefault()}));const realTimeUpdate=()=>{this.emitOver(canvas);this.emitNotOver(canvas);this.emitKeyPress();requestAnimationFrame(realTimeUpdate)};requestAnimationFrame(realTimeUpdate)}details={keyboard:{keys:{}},pointer:{initPos:{x:undefined,y:undefined},currentPos:{x:undefined,y:undefined},finalPos:{x:undefined,y:undefined},start:undefined,end:undefined,duration(){return this.end-this.start}}};emitClick(evt){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.wasClicked(this)){switch(evt.button){case 0:if(value.whenLeftClicked&&value.whenLeftClicked.constructor===Function){value.whenLeftClicked(co)}break;case 1:if(value.whenWheelClicked&&value.whenWheelClicked.constructor===Function){value.whenWheelClicked(co)}break;case 2:if(value.whenRightClicked&&value.whenRightClicked.constructor===Function){value.whenRightClicked(co)}break;default:console.error("A button was clicked but it was not a left, right or wheel click.");break}}}));co.initPos.x=co.initPos.y=co.finalPos.x=co.finalPos.y=undefined}emitTouch(evt){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.wasClicked(this)){if(evt.touches){if(value.whenTouched&&value.whenTouched.constructor===Function){value.whenTouched(co)}}}}));co.initPos.x=co.initPos.y=co.finalPos.x=co.finalPos.y=undefined}emitOver(){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.isUnder()&&value.whenPointerOver){value.whenPointerOver(co)}}))}emitNotOver(element){ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(!value.isUnder()&&value.whenPointerNotOver){value.whenPointerNotOver()}}))}emitKeyPress(){CanvasObject.list.forEach((value=>{if(value.whenKeyPressed){value.whenKeyPressed(this.details.keyboard.keys)}}))}emitKeyRelease(key){CanvasObject.list.forEach((value=>{if(value.whenKeyReleased){value.whenKeyReleased(key)}}))}render(){this.children.forEach((element=>{element.render()}))}}class CanvasObject{static list=[];constructor(x,y,width,height){this.canvas=undefined;this.x=x;this.y=y;this.width=width;this.height=height;this.color=0;this.lastTimeRendered=2;this.maxTimeWithoutRendering=65535;CanvasObject.list.push(this)}propagateClear(){if(this.lastTimeRendered<this.maxTimeWithoutRendering){this.lastTimeRendered++}}setPos(x,y){this.x=x;this.y=y}setSize(width,height){this.width=width;this.height=height}appendTo(parent){if(parent.constructor===Viewer)this.defineCanvas(parent);else if(parent.constructor===ObjectSet)this.defineCanvas(parent.canvas);parent.addChild(this)}defineCanvas(canvas){this.canvas=canvas}getCanvas(){return this.canvas}config(callback){if(callback.constructor===Function)callback(this);return this}render(canvas){this.lastTimeRendered=0;const ctx=canvas.context;const useHoverColor=this.isUnder()&&this.hoverEffect!==false;let hoverValue;if(useHoverColor===true){if(this.hoverEffect===true){const rgba=Color.getColor(this.color);rgba.red-=64;rgba.green-=64;rgba.blue-=64;rgba.red=Math.abs(rgba.red);rgba.green=Math.abs(rgba.green);rgba.blue=Math.abs(rgba.blue);const fixed=Color.fixColor(rgba);hoverValue=Color.objectToNumber(fixed)}else if(this.hoverEffect.constructor===Number){hoverValue=this.hoverEffect}}ctx[`${this.type}Style`]=useHoverColor===false?Color.fromInt(this.color):Color.fromInt(hoverValue)}hit(target){if(this.canvas===target.canvas){const sLeft=this.x,sRight=this.x+this.width,sTop=this.y,sBottom=this.y+this.height;const tLeft=target.x,tRight=target.x+target.width,tTop=target.y,tBottom=target.y+target.height;let collision=true;if(sBottom<tTop||sTop>tBottom||sRight<tLeft||sLeft>tRight){collision=false}return collision}}}class ClickableObject extends CanvasObject{static list=[];constructor(x,y,width,height){super(x,y,width,height);this.whenPointerOver=function(){};this.whenPointerNotOver=function(){};this.whenLeftClicked=function(){};this.whenRightClicked=function(){};this.whenWheelClicked=function(){};this.hoverEffect=true;ClickableObject.list.push(this)}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;return this.getCanvas()&&posNotUndefined&&details.currentPos.x>=this.x&&details.currentPos.y>=this.y&&details.currentPos.x<=this.x+this.width&&details.currentPos.y<=this.y+this.height}wasClicked(element){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const initPos=details.initPos.x>=this.x&&details.initPos.y>=this.y&&details.initPos.x<=this.x+this.width&&details.initPos.y<=this.y+this.height;const finalPos=details.finalPos.x>=this.x&&details.finalPos.y>=this.y&&details.finalPos.x<=this.x+this.width&&details.finalPos.y<=this.y+this.height;return this.isUnder(element)&&posNotUndefined&&initPos&&finalPos}}class Color{constructor(value){this.value=Color.getColor(value);this.alpha=1}static hexToObject(value){let red;let green;let blue;let alpha;const hex=new RegExp("#"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})?");if(hex.test(value)){const captured=value.match(hex);red=parseInt(captured[1],16);green=parseInt(captured[2],16);blue=parseInt(captured[3],16);alpha=parseInt(captured[4]||"FF",16)/255}else return false;return{red:red,green:green,blue:blue,alpha:alpha}}static rgbToObject(value){let red;let green;let blue;let alpha;const rgb=new RegExp("rgba? *"+"( *"+"(25[0-5]|2[0-4]d|1?d?d)"+" *, *"+"(25[0-5]|2[0-4]d|1?d?d)"+" *, *"+"(25[0-5]|2[0-4]d|1?d?d)"+"(?: *, *"+"(1|0(?:.d+)?)"+")? *)");if(rgb.test(value)){const captured=value.match(rgb);red=parseInt(captured[1]);green=parseInt(captured[2]);blue=parseInt(captured[3]);alpha=parseFloat(captured[4]||1)}else return false;return{red:red,green:green,blue:blue,alpha:alpha}}static objectToNumber(value){return 256**2*value.red%256**3+256*value.green%256**2+value.blue%256}static fromInt(value){return"#"+("000000"+value.toString(16)).slice(-6)}static fixColor(value){for(const x of["red","green","blue"]){if(value[x]<0)value[x]=0}return value}static getColor(value){let rgba;if(value.constructor===String){rgba=Color.rgbToObject(value)||Color.hexToObject(value)}else if(value.constructor===Number){rgba=Color.hexToObject(Color.fromInt(value))}const red=rgba.red;const green=rgba.green;const blue=rgba.blue;const alpha=rgba.alpha;return{red:red,green:green,blue:blue,alpha:alpha}}}class Rect extends ClickableObject{constructor(x,y,width,height){super(x,y,width,height);this.lineWidth=1;this.type="fill"}render(){if(!this.canvas)return;const ctx=this.canvas.context;ctx.save();ctx.lineWidth=this.lineWidth;super.render(this.canvas);ctx.beginPath();ctx.rect(this.x,this.y,this.width,this.height);ctx.closePath();ctx[this.type]();ctx.restore()}}class Arc extends ClickableObject{constructor(x,y,radius,start=0,end=2*Math.PI){super(x,y,radius*2,radius*2);this.radius=radius;this.startFrom="right";this.start=start;this.end=end;this.lineWidth=1;this.type="stroke";this.lineToCenter=true;this.closePath=true}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;const currXPos=Math.pow(details.currentPos.x-this.x,2);const currYPos=Math.pow(details.currentPos.y-this.y,2);const outerMatch=currXPos+currYPos<Math.pow(this.radius+this.lineWidth/2,2);const inMatch=currXPos+currYPos>Math.pow(this.radius-this.lineWidth/2,2);let res=this.getCanvas()&&posNotUndefined&&outerMatch;if(this.type!=="fill"){res=res&&inMatch}return res}wasClicked(){const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const initPos=Math.pow(details.initPos.x-this.x,2)+Math.pow(details.initPos.y-this.y,2)<Math.pow(this.radius+this.lineWidth/2,2);const finalPos=Math.pow(details.finalPos.x-this.x,2)+Math.pow(details.finalPos.y-this.y,2)<Math.pow(this.radius+this.lineWidth/2,2);return this.isUnder()&&posNotUndefined&&initPos&&finalPos}setAngle(start,end){this.start=start;this.end=end}hit(target){if(this.canvas===target.canvas){const posNotUndefined=target.x!=undefined&&target.y!=undefined;const currXPos=Math.pow(target.x-this.x,2);const currYPos=Math.pow(target.y-this.y,2);const outerMatch=currXPos+currYPos<Math.pow(this.radius+this.lineWidth/2,2);const inMatch=currXPos+currYPos>Math.pow(this.radius-this.lineWidth/2,2);let res=this.getCanvas()&&posNotUndefined&&outerMatch;if(this.type!=="fill"){res=res&&inMatch}return res}}render(){if(!this.canvas)return;if(this.width<this.radius*2)this.width=this.radius*2;if(this.height<this.radius*2)this.height=this.radius*2;const ctx=this.canvas.context;ctx.save();ctx.lineWidth=this.lineWidth;super.render(this.canvas);ctx.beginPath();if(this.lineToCenter)ctx.lineTo(this.x,this.y);const startFrom=this.startFrom.constructor===String?this.startFrom.toLowerCase():this.startFrom;let offset=startFrom==="bottom"?Math.PI*.5:startFrom==="left"?Math.PI:startFrom==="top"?Math.PI*-.5:startFrom.constructor===Number?startFrom:0;ctx.arc(this.x,this.y,this.radius+(this.type==="fill"?this.lineWidth/2:0),offset+this.start,offset+this.end);if(this.closePath)ctx.closePath();ctx[this.type]();ctx.restore()}}class TextBox extends ClickableObject{constructor(text,x,y,fontSize=10){super(x,y,undefined,fontSize);this.text=text;this.type="fill";this.font={size:fontSize,family:"sans-serif"};this.baseline="alphabetic";this.align="start";this.width=this.getWidth()}getWidth(){const ctx=new OffscreenCanvas(0,0).getContext("2d");ctx.save();ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;ctx.textAlign=this.align;this.width=ctx.measureText(this.text).width;ctx.restore();return this.width}getHeight(){return this.font.size}__getHeight(){const canvas=new OffscreenCanvas(0,0);const ctx=canvas.getContext("2d");ctx.save();ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;ctx.textAlign=this.align;const val=ctx.measureText(this.text);ctx.restore();return val}setText(value){this.text=value}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;const y=this.y+(this.baseline==="top"?0:this.baseline==="hanging"?-this.getHeight()/4:this.baseline==="middle"?-this.getHeight()/2:this.baseline==="alphabetic"?-this.getHeight():-this.getHeight());const height=y+this.getHeight();this.align;return this.getCanvas()&&posNotUndefined&&details.currentPos.x>=this.x&&details.currentPos.y>=y&&details.currentPos.x<=this.x+this.width&&details.currentPos.y<=height}wasClicked(element){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const initPos=details.initPos.x>=this.x&&details.initPos.y>=this.y&&details.initPos.x<=this.x+this.width&&details.initPos.y<=this.y+this.height;const finalPos=details.finalPos.x>=this.x&&details.finalPos.y>=this.y&&details.finalPos.x<=this.x+this.width&&details.finalPos.y<=this.y+this.height;return this.isUnder(element)&&posNotUndefined&&initPos&&finalPos}render(){if(!this.canvas)return;if(this.height<this.font.size)this.height=this.font.size;const ctx=this.canvas.context;ctx.save();super.render(this.canvas);ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;ctx.textAlign=this.align;ctx[`${this.type}Text`](this.text,this.x,this.y);ctx.restore()}}class CanvasImage extends ClickableObject{constructor(image,x,y,width,height){super(x,y,width,height);this.image=new Image;this.image.src=image;this.lineWidth=1;this.type="stroke"}set onload(callback){this.image.onload=callback}render(){this.lastTimeRendered=0;if(!this.canvas)return;const ctx=this.canvas.context;ctx.save();{let hoverValue;const useHoverColor=this.isUnder()&&this.hoverEffect!==false;if(useHoverColor===true){if(this.hoverEffect===true){hoverValue=.5}else if(this.hoverEffect.constructor===Number){hoverValue=this.hoverEffect}}if(useHoverColor)ctx.filter=`brightness(${hoverValue})`}ctx.drawImage(this.image,this.x,this.y,this.width,this.height);ctx.restore()}}function walkProtoChain(obj,callback){const proto=Object.getPrototypeOf(obj);const inherited=proto?walkProtoChain(proto,callback):[];return[...new Set(callback(obj).concat(inherited))]}function getOwnNonEnumPropertyNames(obj){return Object.getOwnPropertyNames(obj).filter((p=>!obj.propertyIsEnumerable(p)))}function getAllPropertyNames(obj){return walkProtoChain(obj,Object.getOwnPropertyNames)}function getAllEnumPropertyNames(obj){return walkProtoChain(obj,Object.keys)}function getAllNonEnumPropertyNames(obj){return walkProtoChain(obj,getOwnNonEnumPropertyNames)}const objs=getAllPropertyNames(Image.prototype);for(let x of objs){if([...getAllPropertyNames(CanvasImage.prototype),"x","y","width","height"].includes(x)){continue}const descriptors=Object.getOwnPropertyDescriptor(CanvasImage.prototype,x);if(!descriptors){Object.defineProperty(CanvasImage.prototype,x,{get:function(){return this.image[x]},set:function(value){this.image[x]=value}})}}class Path extends ClickableObject{constructor(){this.path=[]}add(...elements){for(let i in elements){const element=elements[i];if(element&&element.constructor===Line){element.disablePath()}}}}class Line extends ClickableObject{constructor(x,y,width,height){}}class ObjectSet extends CanvasObject{static list=[];constructor(){super();this.children=[];ObjectSet.list.push(this)}propagateClear(){this.children.forEach((element=>{element.propagateClear()}))}add(...elements){elements.forEach((element=>{if(element instanceof CanvasObject){this.addChild(element);element.defineCanvas(this)}}))}addChild(element){this.children.push(element)}getChild(child){return this.children.find((value=>value==child))}render(){this.children.forEach((element=>{element.render()}))}}return{Viewer:Viewer,CanvasObject:CanvasObject,ClickableObject:ClickableObject,Color:Color,Rect:Rect,Arc:Arc,TextBox:TextBox,CanvasImage:CanvasImage,ObjectSet:ObjectSet}}();