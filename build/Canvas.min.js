const Canvas=function(){function __add(...elements){elements.forEach((element=>{if(element instanceof CanvasObject){this.addChild(element);element.defineCanvas(this)}}))}function __renderSet(){this.children.forEach((element=>{if(element.x+element.width>=0&&element.y+element.height>=0&&element.x<=this.canvas.width&&element.y<=this.canvas.height){element.render()}else{console.warn("not rendering an element.")}}))}class Viewer{children=[];constructor(contextType="2d",startEvents=true){this.dom=document.createElement("canvas");this.dom.tabIndex=0;this.dom.style.setProperty("outline","none","important");this.contextType=contextType;this.context=this.dom.getContext(contextType);if(startEvents)this.listenToEvents();this.canvas=this}clear(){this.context.clearRect(0,0,this.width,this.height);this.children.forEach((element=>{element.propagateClear()}))}addEventListener(...args){this.dom.addEventListener(...args)}set width(value){this.dom.width=value}get width(){return this.dom.width}set height(value){this.dom.height=value}get height(){return this.dom.height}get style(){return this.dom.style}setSize(width,height,css=false){this.width=width;this.height=height;if(css){this.style.width=width;this.style.height=height}}addChild(element){this.children.push(element)}getChild(child){return this.children.find((value=>value==child))}isActive(){return document.activeElement===this.dom}listenToEvents(){const canvas=this.dom;canvas.addEventListener("touchstart",(evt=>{evt.preventDefault();this.details.pointer.start=Date.now();const touch=evt.touches[0];this.details.pointer.initPos.x=this.details.pointer.currentPos.x=touch.clientX*(this.width/canvas.offsetWidth);this.details.pointer.initPos.y=this.details.pointer.currentPos.y=touch.clientY*(this.height/canvas.offsetHeight)}));canvas.addEventListener("touchmove",(evt=>{evt.preventDefault();const touch=evt.touches[0];this.details.pointer.currentPos.x=touch.clientX*(this.width/canvas.offsetWidth);this.details.pointer.currentPos.y=touch.clientY*(this.height/canvas.offsetHeight)}));canvas.addEventListener("touchend",(evt=>{evt.preventDefault();this.details.pointer.end=Date.now();this.details.pointer.finalPos.x=this.details.pointer.currentPos.x;this.details.pointer.finalPos.y=this.details.pointer.currentPos.y;this.emitTouch(evt);this.details.pointer.currentPos.x=undefined;this.details.pointer.currentPos.y=undefined}));canvas.addEventListener("mousedown",(evt=>{this.details.pointer.start=Date.now();this.details.pointer.initPos.x=evt.offsetX*(this.width/canvas.offsetWidth);this.details.pointer.initPos.y=evt.offsetY*(this.height/canvas.offsetHeight)}));canvas.addEventListener("mousemove",(evt=>{this.details.pointer.currentPos.x=evt.offsetX*(this.width/canvas.offsetWidth);this.details.pointer.currentPos.y=evt.offsetY*(this.height/canvas.offsetHeight)}));canvas.addEventListener("mouseup",(evt=>{this.details.pointer.end=Date.now();this.details.pointer.finalPos.x=this.details.pointer.currentPos.x;this.details.pointer.finalPos.y=this.details.pointer.currentPos.y;this.emitClick(evt);this.details.pointer.finalPos.x=undefined;this.details.pointer.finalPos.y=undefined}));canvas.addEventListener("mouseleave",(evt=>{this.details.pointer.currentPos.x=undefined;this.details.pointer.currentPos.y=undefined}));canvas.addEventListener("keydown",(evt=>{if(!this.details.keyboard.keys[evt.key]){this.details.keyboard.keys[evt.key]=true;this.details.keyboard.keysPressed++}}));canvas.addEventListener("keyup",(evt=>{if(this.details.keyboard.keys[evt.key]){this.details.keyboard.keys[evt.key]=false;this.details.keyboard.keysPressed--;if(this.details.keyboard.keysPressed<0){this.details.keyboard.keysPressed=0}}this.emitKeyRelease(evt)}));canvas.addEventListener("contextmenu",(evt=>{if(!this.forceContextDefault)evt.preventDefault()}));const realTimeUpdate=()=>{this.emitOver(canvas);this.emitNotOver(canvas);if(this.details.keyboard.keysPressed)this.emitKeyPress();requestAnimationFrame(realTimeUpdate)};requestAnimationFrame(realTimeUpdate)}details={keyboard:{keysPressed:0,keys:{}},pointer:{initPos:{x:undefined,y:undefined},currentPos:{x:undefined,y:undefined},finalPos:{x:undefined,y:undefined},start:undefined,end:undefined,duration(){return this.end-this.start}}};emitClick(evt){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.wasClicked(this)){switch(evt.button){case 0:if(value.whenLeftClicked&&value.whenLeftClicked.constructor===Function){value.whenLeftClicked(co)}break;case 1:if(value.whenWheelClicked&&value.whenWheelClicked.constructor===Function){value.whenWheelClicked(co)}break;case 2:if(value.whenRightClicked&&value.whenRightClicked.constructor===Function){value.whenRightClicked(co)}break;default:console.error("A button was clicked but it was not a left, right or wheel click.");break}}}));co.initPos.x=co.initPos.y=co.finalPos.x=co.finalPos.y=undefined}emitTouch(evt){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.wasClicked(this)){if(evt.touches){if(value.whenTouched&&value.whenTouched.constructor===Function){value.whenTouched(co)}}}}));co.initPos.x=co.initPos.y=co.finalPos.x=co.finalPos.y=undefined}emitOver(){const co=this.details.pointer;ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(value.isUnder()&&value.whenPointerOver){value.whenPointerOver(co)}}))}emitNotOver(element){ClickableObject.list.forEach((value=>{if(value.lastTimeRendered>1)return false;if(!value.isUnder()&&value.whenPointerNotOver){value.whenPointerNotOver()}}))}emitKeyPress(){CanvasObject.list.forEach((value=>{if(this.whenKeyPressed){this.whenKeyPressed(this.details.keyboard.keys)}}))}emitKeyRelease(evt){CanvasObject.list.forEach((value=>{if(this.whenKeyReleased){this.whenKeyReleased(evt.key)}}))}}Object.defineProperties(Viewer.prototype,{add:{value:__add},render:{value:__renderSet}});class CanvasObject{static list=[];constructor(x,y,width,height){this.canvas=undefined;this.x=x;this.y=y;this.width=width;this.height=height;this.color=0;this.lastTimeRendered=2;this.maxTimeWithoutRendering=65535;CanvasObject.list.push(this)}propagateClear(){if(this.lastTimeRendered<this.maxTimeWithoutRendering){this.lastTimeRendered++}}setPos(x,y){this.x=x;this.y=y}setSize(width,height){this.width=width;this.height=height}appendTo(parent){if(parent.constructor===Viewer)this.defineCanvas(parent);else if(parent.constructor===ObjectSet)this.defineCanvas(parent.canvas);parent.addChild(this)}defineCanvas(canvas){this.canvas=canvas}getCanvas(){return this.canvas}config(callback){if(callback.constructor===Function)callback(this);return this}render(canvas){this.lastTimeRendered=0;const ctx=canvas.context;const useHoverColor=this.isUnder()&&this.hoverEffect!==false;let hoverValue;if(useHoverColor===true){if(this.hoverEffect===true){const rgba=Color.getColor(this.color);rgba.red-=64;rgba.green-=64;rgba.blue-=64;rgba.red=Math.abs(rgba.red);rgba.green=Math.abs(rgba.green);rgba.blue=Math.abs(rgba.blue);const fixed=Color.fixColor(rgba);hoverValue=Color.objectToNumber(fixed)}else if(this.hoverEffect.constructor===Number){hoverValue=this.hoverEffect}}ctx[`${this.type}Style`]=useHoverColor===false?Color.fromInt(this.color):Color.fromInt(hoverValue)}hit(target){if(this.canvas===target.canvas){const sLeft=this.x,sRight=this.x+this.width,sTop=this.y,sBottom=this.y+this.height;const tLeft=target.x,tRight=target.x+target.width,tTop=target.y,tBottom=target.y+target.height;let collision=true;if(sBottom<tTop||sTop>tBottom||sRight<tLeft||sLeft>tRight){collision=false}return collision}}}class ClickableObject extends CanvasObject{static list=[];constructor(x,y,width,height){super(x,y,width,height);this.whenPointerOver=function(){};this.whenPointerNotOver=function(){};this.whenLeftClicked=function(){};this.whenRightClicked=function(){};this.whenWheelClicked=function(){};this.hoverEffect=true;ClickableObject.list.push(this)}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;return this.getCanvas()&&posNotUndefined&&details.currentPos.x>=this.x&&details.currentPos.y>=this.y&&details.currentPos.x<=this.x+this.width&&details.currentPos.y<=this.y+this.height}wasClicked(element){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const initPos=details.initPos.x>=this.x&&details.initPos.y>=this.y&&details.initPos.x<=this.x+this.width&&details.initPos.y<=this.y+this.height;const finalPos=details.finalPos.x>=this.x&&details.finalPos.y>=this.y&&details.finalPos.x<=this.x+this.width&&details.finalPos.y<=this.y+this.height;return this.isUnder(element)&&posNotUndefined&&initPos&&finalPos}}class Color{constructor(value){this.value=Color.getColor(value);this.alpha=1}static hexToObject(value){let red,green,blue,alpha;const hex=new RegExp("#"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})"+"([0-9a-fA-F]{2})?");if(hex.test(value)){const captured=value.match(hex);red=parseInt(captured[1],16);green=parseInt(captured[2],16);blue=parseInt(captured[3],16);alpha=parseInt(captured[4]||"FF",16)/255}else return false;return{red:red,green:green,blue:blue,alpha:alpha}}static rgbToObject(value){let red;let green;let blue;let alpha;const rgb=/^rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})(?:\s*,\s*(1|0?\.\d+))?\s*\)$/;if(rgb.test(value)){const captured=value.match(rgb);red=parseInt(captured[1]);if(red>255)red=255;else if(red<0)red=0;green=parseInt(captured[2]);if(green>255)green=255;else if(green<0)green=0;blue=parseInt(captured[3]);if(blue>255)blue=255;else if(blue<0)blue=0;alpha=parseFloat(captured[4]||1);if(alpha>1)alpha=1;else if(alpha<0)alpha=0}else return false;return{red:red,green:green,blue:blue,alpha:alpha}}static objectToNumber(value){return 256**2*value.red%256**3+256*value.green%256**2+value.blue%256}static fromInt(value){return"#"+("000000"+value.toString(16)).slice(-6)}static fixColor(value={red:0,green:0,blue:0}){const obj={};for(const x in value){if(value[x]<0)obj[x]=0;else if(["red","green","blue"].includes(x)&&value[x]>255){obj[x]=255}else if(x==="alpha"&&value[x]>1){obj[x]=1}else obj[x]=value[x]}return obj}static getColor(value){let rgba;if(value.constructor===String){rgba=Color.rgbToObject(value)||Color.hexToObject(value)}else if(value.constructor===Number){rgba=Color.hexToObject(Color.fromInt(value))}const red=rgba.red;const green=rgba.green;const blue=rgba.blue;const alpha=rgba.alpha;return{red:red,green:green,blue:blue,alpha:alpha}}}class Rect extends ClickableObject{constructor(x,y,width,height){super(x,y,width,height);this.lineWidth=1;this.type="fill"}render(){if(!this.canvas)return;const ctx=this.canvas.context;ctx.save();ctx.lineWidth=this.lineWidth;super.render(this.canvas);ctx.beginPath();ctx.rect(this.x,this.y,this.width,this.height);ctx.closePath();ctx[this.type]();ctx.restore()}}class Arc extends ClickableObject{constructor(x,y,radius,start=0,end=2*Math.PI){super(x,y,radius*2,radius*2);this.radius=radius;this.startFrom="right";this.start=start;this.end=end;this.lineWidth=1;this.type="stroke";this.lineToCenter=true;this.closePath=true}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;const currXPos=Math.pow(details.currentPos.x-this.x,2);const currYPos=Math.pow(details.currentPos.y-this.y,2);const outerMatch=currXPos+currYPos<Math.pow(this.radius+this.lineWidth/2,2);const inMatch=currXPos+currYPos>Math.pow(this.radius-this.lineWidth/2,2);let res=this.getCanvas()&&posNotUndefined&&outerMatch;if(this.type!=="fill"){res=res&&inMatch}return res}wasClicked(){const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const initPos=Math.pow(details.initPos.x-this.x,2)+Math.pow(details.initPos.y-this.y,2)<Math.pow(this.radius+this.lineWidth/2,2);const finalPos=Math.pow(details.finalPos.x-this.x,2)+Math.pow(details.finalPos.y-this.y,2)<Math.pow(this.radius+this.lineWidth/2,2);return this.isUnder()&&posNotUndefined&&initPos&&finalPos}setAngle(start,end){this.start=start;this.end=end}hit(target){if(this.canvas===target.canvas){const posNotUndefined=target.x!=undefined&&target.y!=undefined;const currXPos=Math.pow(target.x-this.x,2);const currYPos=Math.pow(target.y-this.y,2);const outerMatch=currXPos+currYPos<Math.pow(this.radius+this.lineWidth/2,2);const inMatch=currXPos+currYPos>Math.pow(this.radius-this.lineWidth/2,2);let res=this.getCanvas()&&posNotUndefined&&outerMatch;if(this.type!=="fill"){res=res&&inMatch}return res}}render(){if(!this.canvas)return;if(this.width<this.radius*2)this.width=this.radius*2;if(this.height<this.radius*2)this.height=this.radius*2;const ctx=this.canvas.context;ctx.save();ctx.lineWidth=this.lineWidth;super.render(this.canvas);ctx.beginPath();if(this.lineToCenter)ctx.lineTo(this.x,this.y);const startFrom=this.startFrom.constructor===String?this.startFrom.toLowerCase():this.startFrom;let offset=0;switch(startFrom){case"bottom":offset=Math.PI*.5;break;case"left":offset=Math.PI;break;case"top":offset=Math.PI*-.5;break;default:if(startFrom.constructor===Number){offset=startFrom}break}ctx.arc(this.x,this.y,this.radius+(this.type==="fill"?this.lineWidth/2:0),offset+this.start,offset+this.end);if(this.closePath)ctx.closePath();ctx[this.type]();ctx.restore()}}class TextBox extends ClickableObject{#offscr_canvas=new OffscreenCanvas(0,0);#offscr_ctx=this.#offscr_canvas.getContext("2d");constructor(text,x,y,fontSize=10){super(x,y);this.text=text;this.type="fill";this.font={size:fontSize,family:"sans-serif"};this.baseline="alphabetic";this.align="start"}set width(width){if(this.font){const targetWidth=width;const canvasWidth=this.canvas.width;let minFontSize=1;let maxFontSize=canvasWidth;while(maxFontSize-minFontSize>1){const fontSize=Math.floor((minFontSize+maxFontSize)/2);const textWidth=this.getWidth(fontSize);if(textWidth<targetWidth){minFontSize=fontSize}else{maxFontSize=fontSize}}this.font.size=minFontSize}}get width(){return this.getWidth()}set height(height){if(this.font)this.font.size=height}get height(){return this.font.size}getTrueXPos(){const ctx=this.#offscr_ctx;ctx.save();ctx.restore()}getTrueYPos(){const ctx=this.#offscr_ctx;ctx.save();ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;const metrics=ctx.measureText(this.text);let y=this.y;if(this.baseline!=="top"){y-=metrics.fontBoundingBoxAscent;if(this.baseline==="ideographic"){y+=metrics.fontBoundingBoxDescent}else if(this.baseline==="bottom"){y+=metrics.actualBoundingBoxDescent/2}}ctx.restore();return y}getWidth(fontSize,fontFamily){const ctx=this.#offscr_ctx;ctx.save();ctx.font=`${fontSize??this.font.size}px ${fontFamily??this.font.family}`;const width=ctx.measureText(this.text).width;ctx.restore();return width}getHeight(){return this.font.size}__getHeight(){const canvas=this.#offscr_ctx;const ctx=canvas.getContext("2d");ctx.save();ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;ctx.textAlign=this.align;const val=ctx.measureText(this.text);ctx.restore();return val}setText(value){this.text=value}isUnder(){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.currentPos.x!=undefined&&details.currentPos.y!=undefined;const y=this.getTrueYPos();const height=this.getHeight();return this.getCanvas()&&posNotUndefined&&details.currentPos.x>=this.x&&details.currentPos.y>=y&&details.currentPos.x<=this.x+this.width&&details.currentPos.y<=y+height}wasClicked(element){if(!this.canvas)return;const canvas=this.canvas;const details=canvas.details.pointer;const posNotUndefined=details.initPos.x!=undefined&&details.initPos.y!=undefined;const y=this.getTrueYPos();const initPos=details.initPos.x>=this.x&&details.initPos.y>=y&&details.initPos.x<=this.x+this.width&&details.initPos.y<=y+this.height;const finalPos=details.finalPos.x>=this.x&&details.finalPos.y>=y&&details.finalPos.x<=this.x+this.width&&details.finalPos.y<=y+this.height;return this.isUnder(element)&&posNotUndefined&&initPos&&finalPos}render(){if(!this.canvas)return;if(this.height<this.font.size)this.height=this.font.size;const ctx=this.canvas.context;ctx.save();super.render(this.canvas);ctx.font=`${this.font.size}px ${this.font.family}`;ctx.textBaseline=this.baseline;ctx.textAlign=this.align;ctx[`${this.type}Text`](this.text,this.x,this.y);ctx.restore()}}class CanvasImage extends ClickableObject{constructor(image,x,y,width,height){super(x,y,width,height);this.image=new Image;this.image.src=image;this.lineWidth=1;this.type="stroke"}set onload(callback){this.image.onload=callback}render(){this.lastTimeRendered=0;if(!this.canvas)return;const ctx=this.canvas.context;ctx.save();{let hoverValue;const useHoverColor=this.isUnder()&&this.hoverEffect!==false;if(useHoverColor===true){if(this.hoverEffect===true){hoverValue=.5}else if(this.hoverEffect.constructor===Number){hoverValue=this.hoverEffect}}if(useHoverColor)ctx.filter=`brightness(${hoverValue})`}ctx.drawImage(this.image,this.x,this.y,this.width,this.height);ctx.restore()}}function walkProtoChain(obj,callback){const proto=Object.getPrototypeOf(obj);const inherited=proto?walkProtoChain(proto,callback):[];return[...new Set(callback(obj).concat(inherited))]}function getOwnNonEnumPropertyNames(obj){return Object.getOwnPropertyNames(obj).filter((p=>!obj.propertyIsEnumerable(p)))}function getAllPropertyNames(obj){return walkProtoChain(obj,Object.getOwnPropertyNames)}function getAllEnumPropertyNames(obj){return walkProtoChain(obj,Object.keys)}function getAllNonEnumPropertyNames(obj){return walkProtoChain(obj,getOwnNonEnumPropertyNames)}const objs=getAllPropertyNames(Image.prototype);for(let x of objs){if([...getAllPropertyNames(CanvasImage.prototype),"x","y","width","height"].includes(x)){continue}const descriptors=Object.getOwnPropertyDescriptor(CanvasImage.prototype,x);if(!descriptors){Object.defineProperty(CanvasImage.prototype,x,{get:function(){return this.image[x]},set:function(value){this.image[x]=value}})}}class Path extends ClickableObject{constructor(){super();this.path=[]}add(...elements){for(let i in elements){const element=elements[i];if(element&&element.constructor===Line){element.disablePath()}}}}class Line extends ClickableObject{constructor(x,y,width,height){super(x,y,width,height)}}class ObjectSet extends CanvasObject{static list=[];constructor(x,y){super(x,y);this.children=[];ObjectSet.list.push(this)}propagateClear(){this.children.forEach((element=>{element.propagateClear()}))}addChild(element){this.children.push(element)}getChild(child){return this.children.find((value=>value==child))}}Object.defineProperties(ObjectSet.prototype,{add:{value:__add},render:{value:__renderSet}});return{Viewer:Viewer,CanvasObject:CanvasObject,ClickableObject:ClickableObject,Color:Color,Rect:Rect,Arc:Arc,TextBox:TextBox,CanvasImage:CanvasImage,ObjectSet:ObjectSet}}();